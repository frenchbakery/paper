\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{caption}
% next 2 needed for code blocks
\usepackage{listings}
%\usepackage{etoolbox}  % needed for number detection, but didn't work reliably


\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% colors for code blocks
\definecolor{code-variable}{HTML}{E06C75}
\definecolor{code-keyword}{HTML}{A626A4}
\definecolor{code-string}{HTML}{60A14F}
\definecolor{code-number}{HTML}{986801}
\definecolor{code-comment}{HTML}{A0A1A7}

% definition to detect numbers

%\newtoggle{InString}{}% Keep track of if we are within a string
%\togglefalse{InString}% Assume not initally in string
%
%\newcommand*{\ColorIfNotInString}[1]{\iftoggle{InString}{#1}{\color{red}#1}}%
%\newcommand*{\ProcessQuote}[1]{#1\iftoggle{InString}{\global\togglefalse{InString}}{\global\toggletrue{InString}}}%

% Code blocks
\lstdefinelanguage{JavaScript}{
    keywords={typeof, new, true, false, catch, function, return, null, catch, switch, const, let, var, if, in, for, while, do, else, case, break},
    keywordstyle=\color{blue}\bfseries,
    ndkeywords={class, export, boolean, throw, implements, import, this},
    ndkeywordstyle=\color{darkgray}\bfseries,
    identifierstyle=\color{black},
    sensitive=false,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]',
    morestring=[b]" %,
    %literate=%
    %    {"}{{{\ProcessQuote{"}}}}1% Disable coloring within double quotes
    %    {'}{{{\ProcessQuote{'}}}}1% Disable coloring within single quote
    %    {`}{{{\ProcessQuote{`}}}}1% Disable coloring backtick quote
    %    {0}{{{\ColorIfNotInString{0}}}}1
    %    {1}{{{\ColorIfNotInString{1}}}}1
    %    {2}{{{\ColorIfNotInString{2}}}}1
    %    {3}{{{\ColorIfNotInString{3}}}}1
    %    {4}{{{\ColorIfNotInString{4}}}}1
    %    {5}{{{\ColorIfNotInString{5}}}}1
    %    {6}{{{\ColorIfNotInString{6}}}}1
    %    {7}{{{\ColorIfNotInString{7}}}}1
    %    {8}{{{\ColorIfNotInString{8}}}}1
    %    {9}{{{\ColorIfNotInString{9}}}}1
}

\lstnewenvironment{code-js}{
    \lstset{
        language=javascript,
        frame=none,
        aboveskip=3mm,
        belowskip=3mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle={\small\ttfamily},
        numbers=none,
        numberstyle=\color{code-number},    % line numbers? we want code numbers
        keywordstyle=\color{code-keyword},
        commentstyle=\color{code-comment},
        stringstyle=\color{code-string},
        breaklines=true,
        breakatwhitespace=true,
        tabsize=3
    }
}
{}

\lstnewenvironment{code-cpp}{
    \lstset{
        language=C++,
        frame=none,
        aboveskip=3mm,
        belowskip=3mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle={\small\ttfamily},
        numbers=none,
        numberstyle=\color{code-number},    % line numbers? we want code numbers
        keywordstyle=\color{code-keyword},
        commentstyle=\color{code-comment},
        stringstyle=\color{code-string},
        breaklines=true,
        breakatwhitespace=true,
        tabsize=3
    }
}
{}

\begin{document}

\title{Programmer friendly communication framework}

\author{
    \IEEEauthorblockN{1\textsuperscript{st} Lilo Zobl}
    \IEEEauthorblockA{
        \textit{Botball Team FrenchBakery} \\
        \textit{HTL Anichstraße}\\
        Innsbruck, Austria \\
        lzobl@tsn.at
    }
    \and
    \IEEEauthorblockN{2\textsuperscript{nd} Matteo Reiter}
    \IEEEauthorblockA{
        \textit{Botball Team FrenchBakery} \\
        \textit{HTL Anichstraße}\\
        Innsbruck, Austria \\
        mareiter@tsn.at
    }
}

\maketitle

\begin{abstract}
    This document will focus on an important topic in software development: Network communication. It will provide an insight into why what network communication is needed for and how it is typically realized. Additionally it will cover problems and annoyances with currently available communication frameworks for a specific user-level applications as well as introduce concepts and a possible solution for the before-mentioned. 
\end{abstract}

\section{Introduction}

When it comes to computer science and robotics, sooner or later, multiple computers need to communicate with each other. In many cases this communication is achieved over a computer network. Nowadays this is typically implemented using the internet protocol (IP).

\subsection{IP Networks}

Without going into detail of how the Internet Protocol or any of it's underlying technologies work (out of the scope of this paper), this section provides a quick overview of IP.

In an IP network, every participating communication party (so called "host",such as a computer) is assigned an IP Address (either manually by the Administrator or using automated systems such as DHCP which will not be explained further). The IP address is the lowest level of addressing most user-level applications have to deal with. It is a 32-Bit number typically expressed by four octets (bytes) in dot notation: \textbf{192.168.1.1}

The IP address is split into two parts: the network address bits (some number of bits on the left of the address) and the host address bits (the rest of the bits on the right side). How many of the bits are part of the network and host area is variable and defined by a so-called netmask, which will not be discussed in more detail. All host with the same network-address-bits are considered to be on the same network and can therefore communicate with each other. Each host is uniquely identified in the network by the host-address-bits.

The Internet Protocol provides the foundations for transmitting data between hosts on this network (or possibly multiple networks): IP network packets. These contain Among other details, the sender and receiver addressing information and a block of data to be transmitted between the host. The operating system's network stack and other networking hardware then switch and route the packet from the sender to the desired destination host.

When  developing applications however, the programmer almost never has to worry about the working of these underlying systems. Instead, they use higher level protocols build on top of IP, which abstract abstract IP packets and allow programmers to more conveniently achieve the desired functionality.

\subsection{TCP and UDP protocols}

There are two main protocols on top of IP for user applications - TCP and UDP. 

TCP stands for \textbf{Transmission Control Protocol} and is a connection based protocol, meaning there will be a standing connection between two hosts. Before any data can be sent over TCP, a connection has to be established during an initial handshake between both communication parties. This is done automatically in the background. Once established, a TCP connection provides a pipe-like environment for transmitting a continuous stream of data bytes. The stream is of undefined length and data sent by one host is guaranteed to be received in the same order as sent by the other (without missing bytes in between). However, since TCP "streams" bytes, it does guarantee that any block of bytes send is received in one piece.

UDP stands for \textbf{User Datagram Protocol}. Unlike TCP, UDP does not require a connection to be established. The UDP merely sends a block of data (called the user datagram) all at once to a destination host in a single IP packet. There is nothing set in place to ensure that the packet reaches the destination. Without further protocols, UDP packets do not have any relation to each other, therefore there is no insurance of the order packets are received. Since the entire datagram is sent in one IP packet, it's maximum is restricted to the limits imposed by the latter.\textcolor{red}{(65.535 bytes)} \textcolor{red}{(Achtung!!!!!!!!!!!!!!!!!!!!!! wenn man mehrere geräte hat verwendet man oft eigentlich UDP da das schneller geht)}

UDP is less reliable than TCP. Before choosing a respective protocol one has to decide if they need speed or reliability more. A common uses for UDP are videos whereas a common use for TCP are websites.



From here on, this paper will focus on point-to-point communication between two hosts, although many of the concepts described later are also applicable to \textcolor{red}{multicast communication}.
For this reason, it will focus on higher-level protocols and frameworks based on TCP from here-on out.

\subsection{Communication frameworks}

While TCP communication is the basis of many point-to-point networking applications requiring data integrity, it is still rather tedious for a programmer to implement in high-level applications. The programmer still has to know how to use the OS APIs to create and manage TCP sockets and since only bytes can be sent over the socket, the programmer needs to manually serialize and deserialize internal program structures and variables to transmit them. Besides this, raw TCP is only really suited for continuous data streams, while many applications require event-based bidirectional communication where messages (blocks of data with clear boundaries) are sent back and fourth.

Providing solutions for these \textcolor{red}{annoyances/problems} is the job of communication frameworks. A communication framework does not only implement a higher level protocol to support the additional functionality, but also provides libraries of programming language functions to integrate the functionality as seamlessly as possible with language features.

The work described in this paper aims to create a communication framework to solve problems for a rather specific set of requirements.:

\begin{enumerate}
    \item Abstraction of low-level socket APIs, exposing the most important functionality with little code and automatically handle the rest in the background (according to common use-cases) including but not limited to:
    \begin{itemize}
        \item Automatic management of connection state, handling disconnects and reconnects
    \end{itemize}
    \item Provide a way to exchange messages, which are blocks of data of a known (but still possibly dynamic) length, guaranteeing arrival in same grouping and order as sent
    \item Provide facilities to serialize and deserialize language-native data structures to easily send them over the network with the least code possible
    \item Provide data validation for sent and received messages according to programmer defined schemas (in language native format as far as possible), so the user code can trust received data to be in valid format.
    \item Provide additional, commonly used communication schemes and primitives such as metadata exchange or Remote Procedure Calls (RPCs). These further simplify common practices within network communication for the developer
\end{enumerate}


\section{State of the Art}

There are many different network protocols and accompanying frameworks building on top of the above described, which solve different problems depending on the application requirements. Not all of them will be described in this paper.


\textcolor{red}{(possible section "Motivation")}
The following section explains a typical protocol stack used for web apps, since one of the original primary use-cases of the work described in this paper is the communication between a single-page web-app and a high performance, low level server written in C++. This used to implement (among other uses) to implement the touchscreen UI to control FrenchBakery robots for the Botball competition. Since web browsers offer only limited to no access to system socket APIs, a large part of the protocol stack used is already defined.

That being said, the following is the protocol stack used as a starting point for the improvements described later.

\subsection{Transmission Control Protocol (TCP)}

\textbf{TCP} as the underlying transportation layer. In an end-user application, this would typically only be used directly if a very high performance custom application protocol is key.


\subsection{Hyper Text Transfer Protocol (HTTP)}

\textbf{HTTP} builds on top of TCP. This protocol is used to transmit files and other chunks of data (such as JSON documents) between servers or between servers and a browser. One limitation is that HTTP is (mostly) unidirectional communication. HTTP works by the client connecting to a server using TCP and then sending an \textbf{HTTP Request}. The request consists of at least one line of human readable text denoting the requested resource (like an HTML file) and some optional parameters, called headers. The end of the request is identified by a CRLF sequence (an empty line of text). Depending on the request details, the server may then answers with some status code, response headers and finally the requested data.

There are libraries for most programming languages, allowing the programmer to send and listen for HTTP request with very little code, varying depending on language.

\begin{code-js}
// JavaScript
let resp = await fetch("http://10.5.5.5/");
\end{code-js}

By automatically handling TCP connection establishment and implementing a way to transfer connection metadata and status codes, HTTP already implements parts of point 1) and 5) of the before mentioned goals for a communication framework.


\subsection{WebSockets}

\textbf{WebSockets} are a bidirectional communication protocol building on top of and somewhat besides HTTP. A WebSocket works by first establishing a TCP connection and sending an HTTP request to a server. However instead of requesting or transmitting a resource directly, the client requests the server to change the protocol on top of the already open TCP socket to the WebSocket protocol using HTTP protocol upgrade headers. Since browsers don't allow web pages and web applications to create TCP sockets directly, this is the only way to create a long-term bidirectional communication channel between the browser and a server application. 

The WebSocket protocol however doesn't expose the raw stream socket to the programmer, instead it introduced the concept of messages, hereby implementing point 2) of the goals for a communication framework. A message is a self contained chunk of data (typically a string, raw binary is also possible) the transmission of which over the socket is transparent to the user. When the programmer sends messages, they guaranteed to arrive at the other communication party in one piece and in order in a message handler.

Like with HTTP, many languages provide simple APIs to create and use WebSocket connections. \cite{b3}

\begin{code-js}
// JavaScript
// connect
let socket = new WebSocket("ws://10.5.5.5/");
// send message
socket.send("hello");
// receive message
socket.onmessage = (e) => {
    console.log(e.data);
}
\end{code-js}


\subsection{Socket.IO}

\textbf{Socket.IO} again builds on top of WebSockets and is the last protocol in the here-described stack. Socket.IO works on the principle of sending events over the network. An event can be imagined like a message consisting of an \textbf{event name} and some \textbf{event data}. Events are identified by their name and there can be multiple different event names in an active connection. As soon as the connection between the server and client is established, both sides can \textbf{emit} and \textbf{listen} for events identified by their name. Listening works by registering callback (handler) functions, to be called when a specific event is received (i.e. emitted by the other communication party). When emitting an event, one can also send some additional data with it, which will be passed to the listener functions.

Thanks to support libraries for multiple programming languages, Socket.IO also provides the functionality to serialize and deserialize the data to language-native structures (at least for some languages) and therefore partially satisfies goal 3). All this functionality can be achieved with very little code.

\begin{code-js}
// JavaScript client connect
const socket = io("ws://10.5.5.5");
// emit event
socket.emit("myevent", "some", [47, "data"]);
// listen for event
socket.on("event2", (arg1, arg2, ...) => {
    console.log("event2:", arg1, arg2);
})
\end{code-js}

Socket.IO also further implements the abstractions outlined by goal 1) of a communication framework, by implementing automatic connection state management and reconnects. Where with WebSockets, the programmer explicitly needs to write code to \textbf{connect to a server},  \textbf{detect disconnects}, and repeat the procedure, with Socket.IO, the programmer is merely required to tell the computer to \textbf{"be connected to a specified server"}. The library will then connect, detect failures and reconnect automatically to satisfy this request. \cite{b1}


\section{Problems with current offer}

Although this protocol stack satisfies the most important goals listed, it still has some problems to be solved, namely the following:

\begin{enumerate}
    \item The Events system provided by Socket.IO is useful for many applications, sometimes responses to events are required, which is often times named a \textbf{Remote Procedure Call}. This needs to be implemented manually for every event:
    \begin{itemize}
        \item define and keep track of a separate request and response event
        \item add an identifying element to request and response data to identify which response belongs to which request and prevent mixing up responses if multiple requests are sent out in short succession
        \item keep a list of open requests to handle responses once received.
    \end{itemize}
    Since the implementation is the same every time and is potentially needed many times in an application, it should be abstracted by the framework.
    \item While Socket.IO provides a very clean and feature-complete API for some programming languages (like Python and JavaScript), it doesn't to so for others, like C++ which is only supported for clients. While there are libraries to create C++ WebSocket servers and clients (like websocket++ which is used in this paper), they require a lot of code (to some part due to the nature of the language) and tedious state management when used directly. Additionally, the event system would need to be implemented manually for every event every time which is tedious.
    \item The data serialization and deserialization of Socket.IO is fully dynamic, meaning that before an event is actually processed, the code cannot possibly know the structure of the event data. This presents multiple problems:
    \begin{itemize}
        \item Deserialization of event data to language-native data structures is impossible for statically typed languages like C++, which \textcolor{red}{nullifies (bad wording?)} the benefits of static typing. It requires the use of dynamic containers like maps to represent objects with strings as attribute names. Since the containers need to be fully dynamic, the programmer first needs to write code to check if an expected attribute exists, assert its's type and finally convert it to the representative language-native type.
        \item Even in dynamic languages like JavaScript where objects can have dynamic attributes and variables are dynamically typed, it is still necessary or at least helpful to perform the same validation to provide adequate error handling and avoid unexpected behaviors. There are also additional systems (TypeScript for JS and type hints for Python) that provide the benefits of static typing even though the underlying language is dynamic. An example is rich IntelliSense editor support to avoid typos in attribute names.
    \end{itemize}
    Since validation should always be performed (expect when explicitly specifying a type to be unknown), it should be abstracted by the communication framework. Instead of the programmer having to write the validation code, the programmer will define the structure of the expected value in a language native format as far as possible (structures in C++, Zod schemas in JS/TS). The framework is then responsible for performing the validation, so data reaching the user's code is guaranteed to have the expected structure.
\end{enumerate}


\section{Solution and Design Overview}

To solve the before mentioned problems, and implement the last missing goals of data validation and more, the top-level protocol in the stack (Socket.IO) will be replaced by a new protocol with language support libraries which has been named \textbf{msglink}.

msglink will build on top of WebSockets, implementing all features of Socket.IO that are relevant to achieve the listed goals. In addition it will add direct framework support for more commonly used communication schemes.

\textcolor{red}{remove this paragraph?}
It should be noted here, that msglink is a point-to-point communication protocol, like WebSocket and Socket.IO. Socket.IO provides the ability to send events from a server to multiple connected clients, which is possible to implement using msglink but is not a primary goal and will not be covered here.

These are the core principles of the msglink framework:

\begin{itemize}
    \item Simple API
    \item Automatic state management
    \item Platform independence
    \item Data validation
    \item Strict type-safety
    \item Communication party equality
    \item Provision of common communication primitives
    \item Bandwidth efficiency
\end{itemize}


\section{Implementation}

This section will cover how the the core principles of the msglink framework work and how they solve the problems and implement the goals listed above.


\subsection{Simple API}

Similar to the protocols and accompanying libraries listed above (especially Socket.IO), msglink tries to achieve it's core functionality with the least code possible using a declarative API. Rather than writing code explicitly stating how to perform the serialization, validation or communication step-by-step (imperative programming), the developer writes code specifying (declaring) what result is expected (declarative programming).

Like Socket.IO, to connect an msglink client to a server, one only has to specify what server the client should \textbf{be connected to} and the library will automatically handle connection and reconnection in case of connection loss. 


\subsection{Automatic state management}

Like Socket.IO, msglink uses a heartbeat (ping-pong) system to determine when the connection drops. This happens internally and requires no code from the user. It works by sending a small message back and fourth every few seconds. In msglink, the server is responsible for sending this so called "ping" message to the client. If the client doesn't respond with the corresponding "pong" message withing a certain time, the connection is dropped. Similarly, if the client doesn't receive a ping in a certain amount of time, it drops the connection on it's side and attempts to reconnect automatically.


\subsection{Platform independence}

msglink should be able to be used with different programming languages and on any operating system. All implementations should be able to communicate with each other.


\subsection{Data validation and strict type-safety}

A key feature of msglink is the above discussed integrated data validation, along with other type-safety features (as far as the specific programming language allows).

Even though msglink is the top-level protocol in the newly defined protocol stack, the end-user application's communication itself also happens according to some protocol, defined by the application developer. The job of the communication framework (msglink) is, to make the implementation and definition of this protocol as simple as possible. In msglink, this user-level protocol is called the \textbf{link}.

Unlike Socket.IO, msglink requires this link to be fully defined in a static manner, meaning the programmer has to explicitly state the existence and associated data structure of every communication primitive (e.g. an event, but msglink has others as well) before it can be used for communication. In case of an event, that would mean explicitly stating that an event with a given name exists, wether it can be emitted or just be received and providing the schema for the data structure transmitted with the event. All of these definitions have to happen statically, so that (for applicable languages) the entire structure of the link (user protocol) is known at compile time. This gives the library the ability to automatically perform validation of the communication and serialization/deserialization of the data from/into language-native formats, even for statically typed languages like C++, without the developer having to manually perform any of those steps.

In msglink, both communication parties have to define the link from their perspective of the communication. This means for example, that an incoming event on one side has to have a matching outgoing event on the other side. When connecting, msglink performs a link-compatibility check, to make sure both parties have defined a compatible protocol. If the two links are not compatible, the connection is aborted before trying to sending any user data.

One of the goals for msglink is, to keep the definition of this link entirely native to the language, so no extra build step is required to generate code from the definition. This has the slight disadvantage of possibly having to write the same schemas with two different syntaxes. 


\subsection{Party equality}

In msglink, both communication parties (client and server) are treated equally. Apart from a few internal details, after a msglink connection is established, both parties can perform the exact same actions, in the bounds of what is defined by the link.


\subsection{Common communication primitives}

msglink defines three commonly used communication primitives that a programmer can use to create the user-protocol.

\begin{itemize}
    \item \textbf{Events} work in the same way as they do with Socket.IO, with the exception of having to define them and their data structure statically.
    \item \textbf{Remote Function Calls} can be viewed as two events with opposite directions. One "call" event and one "result" event. RFCs work as the name implies. One the called (receiving) side of the communication defines a function taking some input data (statically defined by schema) and returning some result data (also defined by a schema). Since a traditional function cannot yield multiple results, there can only be one handler function. The other side of the communication can remotely call the function over the network, efficiently using asynchronous abilities of a language if available so the remote function call can be used almost as seamlessly as a local one. The framework automatically handles the matching of results to pending calls so data is not mixed up. Other framework typically call these Remote Procedure Calls (RPCs), though "function" was chosen for msglink as it clarifies the fact that the call always yields some result data.
    \item \textbf{Data Sources} can be imagined as functions which can be called with some initial input data, that can follow up with more results over time until canceled. This might seem confusing at first, but it is useful for implementing dynamic subscription models. This is best explained using an example: \textit{A web dashboard manages 100 servo actuators and needs to display live updates of their positions. Always transmitting the position of each results is too much traffic. Since only 5 can be displayed on screen at a time, a protocol needs to be implemented to activate or deactivate the updates for each when shown or hidden.} This could be implemented manually using a "sub", "unsub" and "update" event, providing the actuator ID in the "update" event. msglink abstracts and standardizes this however. In the UI component requiring the data of a specific actuator, a data source listener could be registered with the actuator ID as an input argument. This can be imagined as the function being called with the actuator ID as a parameter, and the function then following up with a new result event every time the actuator position updates.
\end{itemize}


\subsection{Bandwidth efficiency}

At the time of writing, the msglink protocol uses JSON to encode it's internal messages as well as user data. This is not very bandwidth efficient, especially when long attribute names are used, which is helpful for development purposes but may be improved in the future. 

Never the less, msglink tries to perform the communication as efficiently as possible by only transmitting data over the network that is actually required. For example, the msglink framework internally tracks whether an event currently has any listeners and informs the other communication party if there are any. If there are no listeners, the event doesn't need to be transmitted over the network, even if one is emitted. A similar concept applies to data sources.


\section{Results and Applications}

\section{Limitations}

\section{Conclusion}




\listoffigures

\begin{thebibliography}{00}

    \bibitem{b1} Information for Socket.io, URL:https://socket.io/
    \bibitem{b2} Information for Zod, URL:https://zod.dev/
    \bibitem{b3} Information for WebSocket++, URL: https://docs.websocketpp.org/ 
    https://github.com/zaphoyd/websocketpp/

\end{thebibliography}

\end{document}
